
#!/usr/bin/env bash
# b: directory bookmarks (XDG). Usage:
#   b                     # list all
#   b <name>              # cd to <name>
#   b <name> --add        # add current dir as <name>
#   b <name> --delete     # delete <name>

# --- config storage (XDG) ---
BOOK_DIR="${XDG_CONFIG_HOME:-"$HOME/.config"}/bash/bookmarks"
BOOK_FILE="$BOOK_DIR/dirs"
TMP_FILE="$BOOK_FILE.tmp"

_mkdirp() { mkdir -p "$BOOK_DIR"; [[ -f "$BOOK_FILE" ]] || : > "$BOOK_FILE"; }
_load()   { _mkdirp; }
_valid_name() { [[ "${1:-}" =~ ^[A-Za-z0-9._-]+$ ]]; }

# percent-encode tabs/newlines to keep file line-oriented
_encode() { local p=$1; p=${p//$'\t'/%09}; p=${p//$'\n'/%0A}; printf '%s' "$p"; }
_decode() { local p=$1; p=${p//%09/$'\t'}; p=${p//%0A/$'\n'}; printf '%s' "$p"; }

_phys() {
  local p=${1:-"$PWD"}
  if command -v realpath >/dev/null 2>&1; then realpath -m -- "$p"
  elif command -v readlink >/dev/null 2>&1; then readlink -f -- "$p" 2>/dev/null || printf '%s\n' "$p"
  else printf '%s\n' "$p"; fi
}

_get_line() {
  _load; local n=$1
  awk -F'\t' -v n="$n" '$1==n{print; exit}' "$BOOK_FILE" 2>/dev/null || true
}

get_path() {
  local n=$1 line; line=$(_get_line "$n") || true
  [[ -n "${line:-}" ]] || return 1
  printf '%s\n' "$line" | cut -f2-
}

save_bookmark() {
  local n=$1 p=$(_phys "${2:-$PWD}")
  _valid_name "$n" || { printf 'invalid name: %s\n' "$n" >&2; return 2; }
  [[ -d "$p" ]] || { printf 'path not found: %s\n' "$p" >&2; return 2; }
  _load
  awk -F'\t' -v n="$n" '$1!=n' "$BOOK_FILE" > "$TMP_FILE" 2>/dev/null || : 
  printf '%s\t%s\n' "$n" "$(_encode "$p")" >> "$TMP_FILE"
  mv "$TMP_FILE" "$BOOK_FILE"
}

delete_bookmark() {
  local n=$1; _valid_name "$n" || { printf 'invalid name: %s\n' "$n" >&2; return 2; }
  _load
  awk -F'\t' -v n="$n" '$1!=n' "$BOOK_FILE" > "$TMP_FILE" 2>/dev/null || :
  mv "$TMP_FILE" "$BOOK_FILE"
}

list_bookmarks() {
  _load
  [[ -s "$BOOK_FILE" ]] || return 0
  local output
  output=$(sort -t$'\t' -k1,1 "$BOOK_FILE" | awk -F'\t' '
    {
      path = $2
      name = $1
      if (!(path in groups)) {
        order[++count] = path
        groups[path] = name
      } else {
        groups[path] = groups[path] ", " name
      }
    }
    END {
      for (i = 1; i <= count; ++i) {
        path = order[i]
        printf "%s\t%s\n", groups[path], path
      }
    }
  ')
  if [[ -t 1 ]] && command -v column >/dev/null 2>&1; then
    printf '%s\n' "$output" | column -t -s $'\t'
  else
    printf '%s\n' "$output"
  fi
}

b() {
  case "${1-}" in
    "" ) list_bookmarks ;;
    -* )
      printf 'b: directory bookmarks\n' >&2
      printf 'usage:\n' >&2
      printf '  b\n' >&2
      printf '  b <name>\n' >&2
      printf '  b <name> --add\n' >&2
      printf '  b <name> --delete\n' >&2
      return 2
      ;;
    *  )
      local name=$1 action=${2-}
      case "$action" in
        "" )
          local enc; enc=$(get_path "$name") || { printf 'no bookmark: %s\n' "$name" >&2; return 2; }
          cd -- "$(_decode "$enc")"
          ;;
        --add )
          save_bookmark "$name"
          ;;
        --delete )
          delete_bookmark "$name"
          ;;
        * )
          printf 'unknown option: %s\n' "$action" >&2; return 2 ;;
      esac
      ;;
  esac
}

# --- tab completion (only for `b`) ---
# Make it resilient: never propagate errors; produce no stderr.
__b_complete() {
  # Guard against shells without bash-completion context
  type compgen >/dev/null 2>&1 || return 0
  COMPREPLY=()
  local cur
  cur="${COMP_WORDS[COMP_CWORD]:-}"
  if (( COMP_CWORD == 1 )); then
    # complete names
    local names
    names="$(list_bookmarks 2>/dev/null | cut -f1 2>/dev/null)"
    COMPREPLY=( $(compgen -W "$names" -- "$cur") )
  else
    COMPREPLY=( $(compgen -W "--add --delete" -- "$cur") )
  fi
  return 0
}

# Register completion if `complete` exists (bash), ignore errors.
type complete >/dev/null 2>&1 && complete -F __b_complete b 2>/dev/null || true
